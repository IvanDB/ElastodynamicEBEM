function intgN = BEMenerg_postProcN_calcMatrixBlock(pbParam, methodInfo, constValuesT, sourcePoint, diffT)
%INPUT
% - 
% -
%
%OUTPUT
% -
%% INIZIALIZZAZIONE VALORI

%VelocitÃ  caratteristiche
cP = pbParam.velP;
cS = pbParam.velS;

%Nucleo integrale
nu = @(x, r, t) [((x(1) * x(1)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  ((1/r) - ((x(1) * x(1)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * ((1/(r^3)) - 3 * ((x(1) * x(1)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0)), ...
                 ((x(1) * x(2)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  (- ((x(1) * x(2)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * (-3 * ((x(1) * x(2)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0)), ....
                 ((x(1) * x(3)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  (- ((x(1) * x(3)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * (-3 * ((x(1) * x(3)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0));
                 ((x(2) * x(1)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  (- ((x(2) * x(1)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * (-3 * ((x(2) * x(1)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0)), ...
                 ((x(2) * x(2)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  ((1/r) - ((x(2) * x(2)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * ((1/(r^3)) - 3 * ((x(2) * x(2)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0)), ....
                 ((x(2) * x(3)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  (- ((x(2) * x(3)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * (-3 * ((x(2) * x(3)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0));
                 ((x(3) * x(1)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  (- ((x(3) * x(1)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * (-3 * ((x(3) * x(1)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0)), ...
                 ((x(3) * x(2)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  (- ((x(3) * x(2)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * (- 3 * ((x(3) * x(2)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0)), ....
                 ((x(3) * x(3)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  ((1/r) - ((x(3) * x(3)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * ((1/(r^3)) -3 * ((x(3) * x(3)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0))];
%Inzializzazione variabile
intgN = zeros(3, 3);

%Inizializzazione numero nodi quadratura
nSR = methodInfo.numSubRegionPP;
nNS = methodInfo.numNodiSingPP;

PPnodes = constValuesT.PPnodes;
PPweights = constValuesT.PPweights;

for indSR = 1 : nSR
    for indNS = 1 : nNS
        indNodo = (nNS * (indSR - 1)) + indNS;

        nodoInt = PPnodes{indNodo};

        vettX = nodoInt - sourcePoint;
        lungX = norm(vettX);

        intgN = intgN + PPweights{indNS} .* nu(vettX, lungX, diffT);
    end
end

%Applicazione coefficiente moltiplicativo comune
intgN = intgN ./ (4*pi*pbParam.rho);

return