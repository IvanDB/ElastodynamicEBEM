function intgTotSing = BEMenerg_dir_calcKIntgSing_uConstSpace(methodInfo, pbParam, diffTemp, constValuesS, constValuesF, normInt, DIAGn, DIAGw, vertsInt)

%% DEFINIZIONE NUCLEI

%Parametri del problema
lambda = pbParam.lambda;
mu = pbParam.mu;
rho = pbParam.rho;

cP = pbParam.velP;
cS = pbParam.velS;

%Tensore di permutazione
tensorE = zeros(3, 3, 3);
tensorE(1, 2, 3) = 1;
tensorE(2, 3, 1) = 1;
tensorE(3, 1, 2) = 1;
tensorE(3, 2, 1) = -1;
tensorE(2, 1, 3) = -1;
tensorE(1, 3, 2) = -1;

nuKL = @(Vr, Lr, Vn, DeltaT) [(lambda/(lambda + mu)) * Vr(1) * Vn(1) / (Lr^3) * ((DeltaT - (Lr/cP)) * ((DeltaT - (Lr/cP)) > 0) - (DeltaT - (Lr/cS)) * ((DeltaT - (Lr/cS)) > 0)) ...
                                        + (mu / (lambda + mu)) * Vr(1) * Vn(1) / (Lr^3) * ((DeltaT - (Lr/cP)) * ((DeltaT - (Lr/cP)) > 0) - (DeltaT - (Lr/cS)) * ((DeltaT - (Lr/cS)) > 0)), ...
                              (lambda/(lambda + mu)) * Vr(1)*Vn(2) / (Lr^3) * ((DeltaT - (Lr/cP)) * ((DeltaT - (Lr/cP)) > 0) - (DeltaT - (Lr/cS)) * ((DeltaT - (Lr/cS)) > 0)) ...
                                        + (mu / (lambda + mu)) * Vr(2) * Vn(1) / (Lr^3) * ((DeltaT - (Lr/cP)) * ((DeltaT - (Lr/cP)) > 0) - (DeltaT - (Lr/cS)) * ((DeltaT - (Lr/cS)) > 0)), ...
                              (lambda/(lambda + mu)) * Vr(1) * Vn(3) / (Lr^3) * ((DeltaT - (Lr/cP)) * ((DeltaT - (Lr/cP)) > 0) - (DeltaT - (Lr/cS)) * ((DeltaT - (Lr/cS)) > 0)) ...
                                        + (mu / (lambda + mu)) * Vr(3) * Vn(1) / (Lr^3) * ((DeltaT - (Lr/cP)) * ((DeltaT - (Lr/cP)) > 0) - (DeltaT - (Lr/cS)) * ((DeltaT - (Lr/cS)) > 0)); ...
                              (lambda/(lambda + mu)) * Vr(2) * Vn(1) / (Lr^3) * ((DeltaT - (Lr/cP)) * ((DeltaT - (Lr/cP)) > 0) - (DeltaT - (Lr/cS)) * ((DeltaT - (Lr/cS)) > 0)) ...
                                        + (mu / (lambda + mu)) * Vr(1) * Vn(2) / (Lr^3) * ((DeltaT - (Lr/cP)) * ((DeltaT - (Lr/cP)) > 0) - (DeltaT - (Lr/cS)) * ((DeltaT - (Lr/cS)) > 0)), ...
                              (lambda/(lambda + mu)) * Vr(2) * Vn(2) / (Lr^3) * ((DeltaT - (Lr/cP)) * ((DeltaT - (Lr/cP)) > 0) - (DeltaT - (Lr/cS)) * ((DeltaT - (Lr/cS)) > 0)) ...
                                        + (mu / (lambda + mu)) * Vr(2) * Vn(2) / (Lr^3) * ((DeltaT - (Lr/cP)) * ((DeltaT - (Lr/cP)) > 0) - (DeltaT - (Lr/cS)) * ((DeltaT - (Lr/cS)) > 0)), ...
                              (lambda/(lambda + mu)) * Vr(2) * Vn(3) / (Lr^3) * ((DeltaT - (Lr/cP)) * ((DeltaT - (Lr/cP)) > 0) - (DeltaT - (Lr/cS)) * ((DeltaT - (Lr/cS)) > 0)) ...
                                        + (mu / (lambda + mu)) * Vr(3) * Vn(2) / (Lr^3) * ((DeltaT - (Lr/cP)) * ((DeltaT - (Lr/cP)) > 0) - (DeltaT - (Lr/cS)) * ((DeltaT - (Lr/cS)) > 0)); ...
                              (lambda/(lambda + mu)) * Vr(3) * Vn(1) / (Lr^3) * ((DeltaT - (Lr/cP)) * ((DeltaT - (Lr/cP)) > 0) - (DeltaT - (Lr/cS)) * ((DeltaT - (Lr/cS)) > 0)) ...
                                        + (mu / (lambda + mu)) * Vr(1) * Vn(3) / (Lr^3) * ((DeltaT - (Lr/cP)) * ((DeltaT - (Lr/cP)) > 0) - (DeltaT - (Lr/cS)) * ((DeltaT - (Lr/cS)) > 0)), ...
                              (lambda/(lambda + mu)) * Vr(3) * Vn(2) / (Lr^3) * ((DeltaT - (Lr/cP)) * ((DeltaT - (Lr/cP)) > 0) - (DeltaT - (Lr/cS)) * ((DeltaT - (Lr/cS)) > 0)) ...
                                        + (mu / (lambda + mu)) *  Vr(2) * Vn(3) / (Lr^3) * ((DeltaT - (Lr/cP)) * ((DeltaT - (Lr/cP)) > 0) - (DeltaT - (Lr/cS)) * ((DeltaT - (Lr/cS)) > 0)), ...
                              (lambda/(lambda + mu)) * Vr(3) * Vn(3) / (Lr^3) * ((DeltaT - (Lr/cP)) * ((DeltaT - (Lr/cP)) > 0) - (DeltaT - (Lr/cS)) * ((DeltaT - (Lr/cS)) > 0))  ...
                                        + (mu / (lambda + mu)) *  Vr(3) * Vn(3) / (Lr^3) * ((DeltaT - (Lr/cP)) * ((DeltaT - (Lr/cP)) > 0) - (DeltaT - (Lr/cS)) * ((DeltaT - (Lr/cS)) > 0))];

nuKT = @(Vr, Lr, Vn, DeltaT) [(lambda/(lambda + mu)) * Vr(1) * Vn(1) / (Lr^2) * ((((DeltaT - (Lr/cP)) > 0) / cP) - (((DeltaT - (Lr/cS)) > 0) / cS)) ...
                                        + (mu / (lambda + mu)) * Vr(1) * Vn(1) / (Lr^2) * ((((DeltaT - (Lr/cP)) > 0) / cP) - (((DeltaT - (Lr/cS)) > 0) / cS)), ...
                              (lambda/(lambda + mu)) * Vr(1) * Vn(2) / (Lr^2) * ((((DeltaT - (Lr/cP)) > 0) / cP) - (((DeltaT - (Lr/cS)) > 0) / cS)) ...
                                        + (mu / (lambda + mu)) * Vr(2) * Vn(1) / (Lr^2) * ((((DeltaT - (Lr/cP)) > 0) / cP) - (((DeltaT - (Lr/cS)) > 0) / cS)), ...
                              (lambda/(lambda + mu)) * Vr(1) * Vn(3) / (Lr^2) * ((((DeltaT - (Lr/cP)) > 0) / cP) - (((DeltaT - (Lr/cS)) > 0) / cS)) ...
                                        + (mu / (lambda + mu)) * Vr(3) * Vn(1) / (Lr^2) * ((((DeltaT - (Lr/cP)) > 0) / cP) - (((DeltaT - (Lr/cS)) > 0) / cS)); ...
                              (lambda/(lambda + mu)) * Vr(2) * Vn(1) / (Lr^2) * ((((DeltaT - (Lr/cP)) > 0) / cP) - (((DeltaT - (Lr/cS)) > 0) / cS)) ...
                                        + (mu / (lambda + mu)) * Vr(1) * Vn(2) / (Lr^2) * ((((DeltaT - (Lr/cP)) > 0) / cP) - (((DeltaT - (Lr/cS)) > 0) / cS)), ...
                              (lambda/(lambda + mu)) * Vr(2) * Vn(2) / (Lr^2) * ((((DeltaT - (Lr/cP)) > 0) / cP) - (((DeltaT - (Lr/cS)) > 0) / cS)) ...
                                        + (mu / (lambda + mu)) * Vr(2) * Vn(2) / (Lr^2) * ((((DeltaT - (Lr/cP)) > 0) / cP) - (((DeltaT - (Lr/cS)) > 0) / cS)), ...
                              (lambda/(lambda + mu)) * Vr(2) * Vn(3) / (Lr^2) * ((((DeltaT - (Lr/cP)) > 0) / cP) - (((DeltaT - (Lr/cS)) > 0) / cS)) ...
                                        + (mu / (lambda + mu)) * Vr(3) * Vn(2) / (Lr^2) * ((((DeltaT - (Lr/cP)) > 0) / cP) - (((DeltaT - (Lr/cS)) > 0) / cS)); ...
                              (lambda/(lambda + mu)) * Vr(3) * Vn(1) / (Lr^2) * ((((DeltaT - (Lr/cP)) > 0) / cP) - (((DeltaT - (Lr/cS)) > 0) / cS)) ...
                                        + (mu / (lambda + mu)) * Vr(1) * Vn(3) / (Lr^2) * ((((DeltaT - (Lr/cP)) > 0) / cP) - (((DeltaT - (Lr/cS)) > 0) / cS)), ...
                              (lambda/(lambda + mu)) * Vr(3) * Vn(2) / (Lr^2) * ((((DeltaT - (Lr/cP)) > 0) / cP) - (((DeltaT - (Lr/cS)) > 0) / cS)) ...
                                        + (mu / (lambda + mu)) *  Vr(2) * Vn(3) / (Lr^2) * ((((DeltaT - (Lr/cP)) > 0) / cP) - (((DeltaT - (Lr/cS)) > 0) / cS)), ...
                              (lambda/(lambda + mu)) * Vr(3) * Vn(3) / (Lr^2) * ((((DeltaT - (Lr/cP)) > 0) / cP) - (((DeltaT - (Lr/cS)) > 0) / cS))  ...
                                        + (mu / (lambda + mu)) *  Vr(3) * Vn(3) / (Lr^2) * ((((DeltaT - (Lr/cP)) > 0) / cP) - (((DeltaT - (Lr/cS)) > 0) / cS))];

nuKsmRj = @(Vr, Lr, DeltaT, j) [(2 * mu / rho) .* (tensorE(j, 1, 2) .* (3 .* Vr(2) .* Vr(1) ./ (Lr^5)) + tensorE(j, 1, 3) .* (3 .* Vr(3) .* Vr(1) ./ (Lr^5))) ...
                                                                            .* ((DeltaT - (Lr/cS))^2 .* (DeltaT + 2.*(Lr/cS)) ./ 6 .* ((DeltaT - (Lr/cS)) > 0) - (DeltaT - (Lr/cP))^2 .* (DeltaT + 2.*(Lr/cP)) ./ 6 .* ((DeltaT - (Lr/cP)) > 0)) ...
                                                + (2 * mu / rho) .* (tensorE(j, 1, 2) .* (Vr(2) .* Vr(1) ./ (Lr^3)) + tensorE(j, 1, 3) .* (Vr(3) .* Vr(1) ./ (Lr^3))) ...
                                                                            .* (((DeltaT - (Lr/cS)) .* ((DeltaT - (Lr/cS)) > 0) / (cS^2)) - ((DeltaT - (Lr/cP)) .* ((DeltaT - (Lr/cP)) > 0) / (cP^2))), ...
                                (lambda * mu / (rho * (lambda+mu))) .* tensorE(j, 2, 1) ./ Lr .* (((DeltaT - (Lr/cS)) .* ((DeltaT - (Lr/cS)) > 0) / (cS^2)) - ((DeltaT - (Lr/cP)) .* ((DeltaT - (Lr/cP)) > 0) / (cP^2))) ...
                                                + (2 * mu / rho) .* (tensorE(j, 1, 2) .* (3 .* Vr(2) .* Vr(2) ./ (Lr^5) - 1 ./ (Lr^3)) + tensorE(j, 1, 3) .* (3 .* Vr(3) .* Vr(2) ./ (Lr^5))) ...
                                                                            .* ((DeltaT - (Lr/cS))^2 .* (DeltaT + 2.*(Lr/cS)) ./ 6 .* ((DeltaT - (Lr/cS)) > 0) - (DeltaT - (Lr/cP))^2 .* (DeltaT + 2.*(Lr/cP)) ./ 6 .* ((DeltaT - (Lr/cP)) > 0)) ...
                                                + (2 * mu / rho) .* (tensorE(j, 1, 2) .* (Vr(2) .* Vr(2) ./ (Lr^3)) + tensorE(j, 1, 3) .* (Vr(3) .* Vr(2) ./ (Lr^3))) ...
                                                                            .* (((DeltaT - (Lr/cS)) .* ((DeltaT - (Lr/cS)) > 0) / (cS^2)) - ((DeltaT - (Lr/cP)) .* ((DeltaT - (Lr/cP)) > 0) / (cP^2))), ...
                                (lambda * mu / (rho * (lambda+mu))) .* tensorE(j, 3, 1) ./ Lr .* (((DeltaT - (Lr/cS)) .* ((DeltaT - (Lr/cS)) > 0) / (cS^2)) - ((DeltaT - (Lr/cP)) .* ((DeltaT - (Lr/cP)) > 0) / (cP^2))) ...
                                                + (2 * mu / rho) .* (tensorE(j, 1, 2) .* (3 .* Vr(2) .* Vr(3) ./ (Lr^5)) + tensorE(j, 1, 3) .* (3 .* Vr(3) .* Vr(3) ./ (Lr^5) - 1 ./ (Lr^3))) ...
                                                                            .* ((DeltaT - (Lr/cS))^2 .* (DeltaT + 2.*(Lr/cS)) ./ 6 .* ((DeltaT - (Lr/cS)) > 0) - (DeltaT - (Lr/cP))^2 .* (DeltaT + 2.*(Lr/cP)) ./ 6 .* ((DeltaT - (Lr/cP)) > 0)) ...
                                                + (2 * mu / rho) .* (tensorE(j, 1, 2) .* (Vr(2) .* Vr(3) ./ (Lr^3)) + tensorE(j, 1, 3) .* (Vr(3) .* Vr(3) ./ (Lr^3))) ...
                                                                            .* (((DeltaT - (Lr/cS)) .* ((DeltaT - (Lr/cS)) > 0) / (cS^2)) - ((DeltaT - (Lr/cP)) .* ((DeltaT - (Lr/cP)) > 0) / (cP^2))); ...
                                (lambda * mu / (rho * (lambda+mu))) .* tensorE(j, 1, 2) ./ Lr .* (((DeltaT - (Lr/cS)) .* ((DeltaT - (Lr/cS)) > 0) / (cS^2)) - ((DeltaT - (Lr/cP)) .* ((DeltaT - (Lr/cP)) > 0) / (cP^2))) ...
                                                + (2 * mu / rho) .* (tensorE(j, 2, 1) .* (3 .* Vr(1) .* Vr(1) ./ (Lr^5) - 1 ./ (Lr^3)) + tensorE(j, 2, 3) .* (3 .* Vr(3) .* Vr(1) ./ (Lr^5))) ...
                                                                            .* ((DeltaT - (Lr/cS))^2 .* (DeltaT + 2.*(Lr/cS)) ./ 6 .* ((DeltaT - (Lr/cS)) > 0) - (DeltaT - (Lr/cP))^2 .* (DeltaT + 2.*(Lr/cP)) ./ 6 .* ((DeltaT - (Lr/cP)) > 0)) ...
                                                + (2 * mu / rho) .* (tensorE(j, 2, 1) .* (Vr(1) .* Vr(1) ./ (Lr^3)) + tensorE(j, 2, 3) .* (Vr(3) .* Vr(1) ./ (Lr^3))) ...
                                                                            .* (((DeltaT - (Lr/cS)) .* ((DeltaT - (Lr/cS)) > 0) / (cS^2)) - ((DeltaT - (Lr/cP)) .* ((DeltaT - (Lr/cP)) > 0) / (cP^2))), ...
                                (2 * mu / rho) .* (tensorE(j, 2, 1) .* (3 .* Vr(1) .* Vr(2) ./ (Lr^5)) + tensorE(j, 2, 3) .* (3 .* Vr(3) .* Vr(2) ./ (Lr^5))) ...
                                                                            .* ((DeltaT - (Lr/cS))^2 .* (DeltaT + 2.*(Lr/cS)) ./ 6 .* ((DeltaT - (Lr/cS)) > 0) - (DeltaT - (Lr/cP))^2 .* (DeltaT + 2.*(Lr/cP)) ./ 6 .* ((DeltaT - (Lr/cP)) > 0)) ...
                                                + (2 * mu / rho) .* (tensorE(j, 2, 1) .* (Vr(1) .* Vr(2) ./ (Lr^3)) + tensorE(j, 2, 3) .* (Vr(3) .* Vr(2) ./ (Lr^3))) ...
                                                                            .* (((DeltaT - (Lr/cS)) .* ((DeltaT - (Lr/cS)) > 0) / (cS^2)) - ((DeltaT - (Lr/cP)) .* ((DeltaT - (Lr/cP)) > 0) / (cP^2))), ...
                                (lambda * mu / (rho * (lambda+mu))) .* tensorE(j, 3, 2) ./ Lr .* (((DeltaT - (Lr/cS)) .* ((DeltaT - (Lr/cS)) > 0) / (cS^2)) - ((DeltaT - (Lr/cP)) .* ((DeltaT - (Lr/cP)) > 0) / (cP^2))) ...
                                                + (2 * mu / rho) .* (tensorE(j, 2, 1) .* (3 .* Vr(1) .* Vr(3) ./ (Lr^5)) + tensorE(j, 2, 3) .* (3 .* Vr(3) .* Vr(3) ./ (Lr^5) - 1 ./ (Lr^3))) ...
                                                                            .* ((DeltaT - (Lr/cS))^2 .* (DeltaT + 2.*(Lr/cS)) ./ 6 .* ((DeltaT - (Lr/cS)) > 0) - (DeltaT - (Lr/cP))^2 .* (DeltaT + 2.*(Lr/cP)) ./ 6 .* ((DeltaT - (Lr/cP)) > 0)) ...
                                                + (2 * mu / rho) .* (tensorE(j, 2, 1) .* (Vr(1) .* Vr(3) ./ (Lr^3)) + tensorE(j, 2, 3) .* (Vr(3) .* Vr(3) ./ (Lr^3))) ...
                                                                            .* (((DeltaT - (Lr/cS)) .* ((DeltaT - (Lr/cS)) > 0) / (cS^2)) - ((DeltaT - (Lr/cP)) .* ((DeltaT - (Lr/cP)) > 0) / (cP^2))); ...
                                (lambda * mu / (rho * (lambda+mu))) .* tensorE(j, 1, 3) ./ Lr .* (((DeltaT - (Lr/cS)) .* ((DeltaT - (Lr/cS)) > 0) / (cS^2)) - ((DeltaT - (Lr/cP)) .* ((DeltaT - (Lr/cP)) > 0) / (cP^2))) ...
                                                + (2 * mu / rho) .* (tensorE(j, 3, 1) .* (3 .* Vr(1) .* Vr(1) ./ (Lr^5) - 1 ./ (Lr^3)) + tensorE(j, 3, 2) .* (3 .* Vr(2) .* Vr(1) ./ (Lr^5))) ...
                                                                            .* ((DeltaT - (Lr/cS))^2 .* (DeltaT + 2.*(Lr/cS)) ./ 6 .* ((DeltaT - (Lr/cS)) > 0) - (DeltaT - (Lr/cP))^2 .* (DeltaT + 2.*(Lr/cP)) ./ 6 .* ((DeltaT - (Lr/cP)) > 0)) ...
                                                + (2 * mu / rho) .* (tensorE(j, 3, 1) .* (Vr(1) .* Vr(1) ./ (Lr^3)) + tensorE(j, 3, 2) .* (Vr(2) .* Vr(1) ./ (Lr^3))) ...
                                                                            .* (((DeltaT - (Lr/cS)) .* ((DeltaT - (Lr/cS)) > 0) / (cS^2)) - ((DeltaT - (Lr/cP)) .* ((DeltaT - (Lr/cP)) > 0) / (cP^2))), ...
                                (lambda * mu / (rho * (lambda+mu))) .* tensorE(j, 2, 3) ./ Lr .* (((DeltaT - (Lr/cS)) .* ((DeltaT - (Lr/cS)) > 0) / (cS^2)) - ((DeltaT - (Lr/cP)) .* ((DeltaT - (Lr/cP)) > 0) / (cP^2))) ...
                                                + (2 * mu / rho) .* (tensorE(j, 3, 1) .* (3 .* Vr(1) .* Vr(2) ./ (Lr^5)) + tensorE(j, 3, 2) .* (3 .* Vr(2) .* Vr(2) ./ (Lr^5) - 1 ./ (Lr^3))) ...
                                                                            .* ((DeltaT - (Lr/cS))^2 .* (DeltaT + 2.*(Lr/cS)) ./ 6 .* ((DeltaT - (Lr/cS)) > 0) - (DeltaT - (Lr/cP))^2 .* (DeltaT + 2.*(Lr/cP)) ./ 6 .* ((DeltaT - (Lr/cP)) > 0)) ...
                                                + (2 * mu / rho) .* (tensorE(j, 3, 1) .* (Vr(1) .* Vr(2) ./ (Lr^3)) + tensorE(j, 3, 2) .* (Vr(2) .* Vr(2) ./ (Lr^3))) ...
                                                                            .* (((DeltaT - (Lr/cS)) .* ((DeltaT - (Lr/cS)) > 0) / (cS^2)) - ((DeltaT - (Lr/cP)) .* ((DeltaT - (Lr/cP)) > 0) / (cP^2))), ...
                                (2 * mu / rho) .* (tensorE(j, 3, 1) .* (3 .* Vr(1) .* Vr(3) ./ (Lr^5)) + tensorE(j, 3, 2) .* (3 .* Vr(2) .* Vr(3) ./ (Lr^5))) ...
                                                                            .* ((DeltaT - (Lr/cS))^2 .* (DeltaT + 2.*(Lr/cS)) ./ 6 .* ((DeltaT - (Lr/cS)) > 0) - (DeltaT - (Lr/cP))^2 .* (DeltaT + 2.*(Lr/cP)) ./ 6 .* ((DeltaT - (Lr/cP)) > 0)) ...
                                                + (2 * mu / rho) .* (tensorE(j, 3, 1) .* (Vr(1) .* Vr(3) ./ (Lr^3)) + tensorE(j, 3, 2) .* (Vr(2) .* Vr(3) ./ (Lr^3))) ...
                                                                            .* (((DeltaT - (Lr/cS)) .* ((DeltaT - (Lr/cS)) > 0) / (cS^2)) - ((DeltaT - (Lr/cP)) .* ((DeltaT - (Lr/cP)) > 0) / (cP^2))) ...
                               ];
%% CALCOLO 

%Estrazione parametri metodo
numNodiExt = methodInfo.numNodiExt;
numNodiDiag = methodInfo.numNodiDiag;
numNodiBound = 64; %valutare e mettere dinamico

%Estrazione parametri triangolo di campo
matCoeffCurr = constValuesF.matCoeff;
vetCoeffCurr = constValuesF.vetCoeff;

%Inizializzazione variabile integrale corrente
intgTotSing = zeros(3);

%Ciclo sui nodi integrazione esterna
for indNodoExt = 1 : numNodiExt
    %Inizializzazione valore singolo integrale interno
    intgIntSing = zeros(3);

    %Lettura nodo e peso esterni correnti
    nodoExt = constValuesS.GHnodes{indNodoExt};
    pesoExt = constValuesS.GHweights{indNodoExt};

    %Cicli per i nodi integrazione interna
    for indChild = 1 : 3
        for indDiag = 1 : numNodiDiag                            
            %Calcolo nodo e peso corrente
            nodoInt = DIAGn(indDiag, :) * constValuesF.DIAGverts{indNodoExt, indChild};
            pesoInt = DIAGw(indDiag) * constValuesF.DIAGarea{indNodoExt, indChild};

            %Calcolo variabili
            vettR = nodoExt - nodoInt;
            lungR = norm(vettR, 2);

            %Calcolo somma dei nuclei
            somNucleiZeta = nuKL(vettR, lungR, normInt, diffTemp) + nuKT(vettR, lungR, normInt, diffTemp);

            %Aggiornamento valore singolo integrale interno
            intgIntSing = intgIntSing + pesoInt .* somNucleiZeta;
        end
    end

    %Cicli per termine di bordo (integro con trapezi)
    intgBoundSing = zeros(3);
    latiInt = {vertsInt(2, :) - vertsInt(1, :), vertsInt(3, :) - vertsInt(2, :), vertsInt(1, :) - vertsInt(3, :)};
    for indL = 1 : 3
        points = vertsInt(indL, :) + linspace(0, 1, numNodiBound + 1)' .* latiInt{indL};
        vettTang = latiInt{indL} ./ norm(latiInt{indL}, 2);
        for indS = 1 : numNodiBound
            vettR = nodoExt - points(indS, :);
            lungR = norm(vettR, 2);
            valStart = nuKsmRj(vettR, lungR, diffTemp, 1) .* vettTang(1) + nuKsmRj(vettR, lungR, diffTemp, 2) .* vettTang(2) + nuKsmRj(vettR, lungR, diffTemp, 3) .* vettTang(3);

            vettR = nodoExt - points(indS+1, :);
            lungR = norm(vettR, 2);
            valEnd = nuKsmRj(vettR, lungR, diffTemp, 1) .* vettTang(1) + nuKsmRj(vettR, lungR, diffTemp, 2) .* vettTang(2) + nuKsmRj(vettR, lungR, diffTemp, 3) .* vettTang(3);

            intgBoundSing = intgBoundSing + ((valStart + valEnd) .* norm(points(indS+1, :) - points(indS, :), 2) ./ 2);
        end
    end
    %Somma pesata contributi
    intgTotSing = intgTotSing + pesoExt .* (intgIntSing + intgBoundSing);
end
return