function ris = BEMenerg_dirD_calcSubBlockDiagV(pbParam, methodInfo, indTemp, deltaT, constValuesBlock, DIAGn, DIAGw)
%% INIZIALIZZAZIONE VALORI

%Velocità caratteristiche
cP = pbParam.velP;
cS = pbParam.velS;

%Nucleo integrale
nu = @(x, r, t) [((x(1) * x(1)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  ((1/r) - ((x(1) * x(1)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * ((1/(r^3)) - 3 * ((x(1) * x(1)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0)), ...
                 ((x(1) * x(2)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  (- ((x(1) * x(2)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * (-3 * ((x(1) * x(2)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0)), ....
                 ((x(1) * x(3)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  (- ((x(1) * x(3)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * (-3 * ((x(1) * x(3)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0));
                 ((x(2) * x(1)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  (- ((x(2) * x(1)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * (-3 * ((x(2) * x(1)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0)), ...
                 ((x(2) * x(2)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  ((1/r) - ((x(2) * x(2)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * ((1/(r^3)) - 3 * ((x(2) * x(2)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0)), ....
                 ((x(2) * x(3)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  (- ((x(2) * x(3)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * (-3 * ((x(2) * x(3)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0));
                 ((x(3) * x(1)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  (- ((x(3) * x(1)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * (-3 * ((x(3) * x(1)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0)), ...
                 ((x(3) * x(2)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  (- ((x(3) * x(2)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * (- 3 * ((x(3) * x(2)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0)), ....
                 ((x(3) * x(3)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  ((1/r) - ((x(3) * x(3)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * ((1/(r^3)) -3 * ((x(3) * x(3)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0))];

%Inizializzazione matrice 
ris = zeros(3, 3);

%Inizializzazione coefficienti
coef = [1, -2, 1];

%Inizializzazione numero nodi 
nGH = methodInfo.numNodiExt;
nDIAGtot = 3 * methodInfo.numNodiDiag;

%% CALCOLO INTEGRALI

%Calcolo indice temporale
istTemp = indTemp + [1, 0, -1];

%Ciclo sui tre istanti temporali
for var = 1 : 3
    %Controllo necessità di calcolo del sottonucleo
    if(istTemp(var) <= 0)
        continue
    end
    intgGHG2DC = zeros(3, 3);

    %Calcolo parametro temporale del sottonucleo
    currT = istTemp(var) * deltaT;

    for indGH = 1 : nGH
        nodoExt = constValuesBlock.GHnodes{indGH};
        intgG2DC = zeros(3, 3);
        
        %% Minore consumo di memoria - maggior numero di conti
        for indChild = 1 : 3
            G2DCnodes = DIAGn * constValuesBlock.DIAGverts{indGH, indChild};
            G2DCweights = DIAGw * constValuesBlock.DIAGarea{indGH, indChild};
            for indG2DC = 1 : methodInfo.numNodiDiag
                nodoInt = G2DCnodes(indG2DC, :);

                vettX = nodoInt - nodoExt;
                lungX = norm(vettX);

                intgG2DC = intgG2DC + G2DCweights(indG2DC) .* nu(vettX, lungX, currT);
            end
        end

        %% Maggior consumo di memoria - minor numero di conti
        % for indG2DC = 1 : nDIAGtot
        %     nodoInt = constValuesBlock.DIAGnodes{indGH, indG2DC};
        % 
        %     vettX = nodoInt - nodoExt;
        %     lungX = norm(vettX);
        % 
        %     intgG2DC = intgG2DC + constValuesBlock.DIAGweights{indGH, indG2DC} .* nu(vettX, lungX, currT);
        % end

        intgGHG2DC = intgGHG2DC + constValuesBlock.GHweights{indGH} .* intgG2DC;

    end
    
    ris = ris + coef(var) .* intgGHG2DC;
end

%Applicazione coefficiente moltiplicativo comune
ris = ris ./ (4*pi*pbParam.rho);

return