function intgGH = BEMenerg_calcIntgInt_GH(pb_param, sourcePoint, vertsT, areaT, curr_t, gha, ghw)
%INPUT
% - 
% -
%
%OUTPUT
% - 

%% SETUP NUCLEO
%VelocitÃ  caratteristiche
cP = pb_param.velP;
cS = pb_param.velS;

%Nucleo integrale
nu = @(x, r, t) [((x(1) * x(1)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  ((1/r) - ((x(1) * x(1)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * ((1/(r^3)) - 3 * ((x(1) * x(1)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0)), ...
                 ((x(1) * x(2)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  (- ((x(1) * x(2)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * (-3 * ((x(1) * x(2)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0)), ....
                 ((x(1) * x(3)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  (- ((x(1) * x(3)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * (-3 * ((x(1) * x(3)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0));
                 ((x(2) * x(1)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  (- ((x(2) * x(1)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * (-3 * ((x(2) * x(1)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0)), ...
                 ((x(2) * x(2)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  ((1/r) - ((x(2) * x(2)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * ((1/(r^3)) - 3 * ((x(2) * x(2)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0)), ....
                 ((x(2) * x(3)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  (- ((x(2) * x(3)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * (-3 * ((x(2) * x(3)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0));
                 ((x(3) * x(1)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  (- ((x(3) * x(1)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * (-3 * ((x(3) * x(1)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0)), ...
                 ((x(3) * x(2)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  (- ((x(3) * x(2)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * (- 3 * ((x(3) * x(2)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0)), ....
                 ((x(3) * x(3)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  ((1/r) - ((x(3) * x(3)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * ((1/(r^3)) -3 * ((x(3) * x(3)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0))];

%% CALCOLO INTEGRALE
%Inzializzazione varialibi
nodoGHFstd = zeros(1, 3);
intgGH = zeros(3, 3);

nghF = pb_param.nghF;

for indGHF = 1 : nghF
    %Estrazione coordinate nodo ghF corrente
    nodoGHFstd(1) = gha(nghF, indGHF, 1);
    nodoGHFstd(2) = gha(nghF, indGHF, 2);
    nodoGHFstd(3) = gha(nghF, indGHF, 3);

    nodoGHFcurr = nodoGHFstd * vertsT;

    vettR = nodoGHFcurr - sourcePoint;
    lungR = norm(vettR);
    
    %Aggiornamento valore pesato
    intgGH = intgGH + (nu(vettR, lungR, curr_t) .* ghw(nghF, indGHF));
end


%Applicazione fattore moltiplicatico relativo all'area del triangolo campo
intgGH = intgGH .* 2 .* areaT;

end