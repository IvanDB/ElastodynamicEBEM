function intgDG1D = BEMenerg_calcIntgInt_DG1D(pb_param, sourcePoint, vertsT, areaT, diffTemp, dgn, dgw)
%INPUT
% - 
% -
%
%OUTPUT
% - 

%% SETUP NUCLEO
%VelocitÃ  caratteristiche
cP = pb_param.velP;
cS = pb_param.velS;

%Nucleo integrale
nu = @(x, r, t) [((x(1) * x(1)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  ((1/r) - ((x(1) * x(1)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * ((1/(r^3)) - 3 * ((x(1) * x(1)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0)), ...
                 ((x(1) * x(2)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  (- ((x(1) * x(2)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * (-3 * ((x(1) * x(2)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0)), ....
                 ((x(1) * x(3)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  (- ((x(1) * x(3)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * (-3 * ((x(1) * x(3)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0));
                 ((x(2) * x(1)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  (- ((x(2) * x(1)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * (-3 * ((x(2) * x(1)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0)), ...
                 ((x(2) * x(2)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  ((1/r) - ((x(2) * x(2)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * ((1/(r^3)) - 3 * ((x(2) * x(2)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0)), ....
                 ((x(2) * x(3)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  (- ((x(2) * x(3)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * (-3 * ((x(2) * x(3)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0));
                 ((x(3) * x(1)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  (- ((x(3) * x(1)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * (-3 * ((x(3) * x(1)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0)), ...
                 ((x(3) * x(2)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  (- ((x(3) * x(2)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * (- 3 * ((x(3) * x(2)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0)), ....
                 ((x(3) * x(3)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  ((1/r) - ((x(3) * x(3)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * ((1/(r^3)) -3 * ((x(3) * x(3)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0))];

%% CALCOLO INTEGRALE
nNodes = pb_param.ngF;

intgDG1D = zeros(3, 3);
nodoGstd = zeros(1, 3);

for i = 1 : nNodes
    for j = 1 : nNodes
        %Estrazione coordinate nodo Gauss corrente
        nodoGstd(1) = dgn(i, j, 1);
        nodoGstd(2) = dgn(i, j, 2);
        nodoGstd(3) = dgn(i, j, 3);

        % Calcolo nodo corrente
        nodoGcurr = nodoGstd * vertsT;

        % Calcolo variabili x e l
        vettX = nodoGcurr - sourcePoint;
        lungX = norm(vettX);

        %Valutazione del nucleo e aggiornamento del risultato temporaneo
        intgDG1D = intgDG1D + dgw(i, j) .* nu(vettX, lungX, diffTemp);
    end

end

%Applicazione fattore moltiplicativo relativo all'area del triangolo
intgDG1D = intgDG1D .* areaT ./ (sqrt(3)/2);
end