function ris = BEMenerg_coreMXGHC_calcMatrixSubBlock(pbParam, methodInfo, indTemp, deltaT, GHnodesS, GHweightsS, GHCnodesF, GHCweightsF)
%INPUT
% - 
% -
%
%OUTPUT
% - 

%% INIZIALIZZAZIONE VALORI

%Velocità caratteristiche
cP = pbParam.velP;
cS = pbParam.velS;

%Nucleo integrale
nu = @(x, r, t) [((x(1) * x(1)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  ((1/r) - ((x(1) * x(1)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * ((1/(r^3)) - 3 * ((x(1) * x(1)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0)), ...
                 ((x(1) * x(2)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  (- ((x(1) * x(2)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * (-3 * ((x(1) * x(2)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0)), ....
                 ((x(1) * x(3)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  (- ((x(1) * x(3)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * (-3 * ((x(1) * x(3)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0));
                 ((x(2) * x(1)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  (- ((x(2) * x(1)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * (-3 * ((x(2) * x(1)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0)), ...
                 ((x(2) * x(2)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  ((1/r) - ((x(2) * x(2)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * ((1/(r^3)) - 3 * ((x(2) * x(2)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0)), ....
                 ((x(2) * x(3)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  (- ((x(2) * x(3)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * (-3 * ((x(2) * x(3)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0));
                 ((x(3) * x(1)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  (- ((x(3) * x(1)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * (-3 * ((x(3) * x(1)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0)), ...
                 ((x(3) * x(2)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  (- ((x(3) * x(2)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * (- 3 * ((x(3) * x(2)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0)), ....
                 ((x(3) * x(3)) / (r^3)) * (1 / (cP^2)) * (t - (r/cP) > 0) ...
                    +  ((1/r) - ((x(3) * x(3)) / (r^3))) * (1 / (cS^2)) * (t - (r/cS) > 0) ...
                    - 0.5 * ((1/(r^3)) -3 * ((x(3) * x(3)) / (r^5))) * ...
                                        ((cP^2 * t^2 - r^2) / cP^2 * (t - (r/cP) > 0) ...
                                          - (cS^2 * t^2 - r^2) / cS^2 * (t - (r/cS) > 0))];

%Inizializzazione matrice 
ris = zeros(3, 3);

%Inizializzazione coefficienti
coef = [1, -2, 1];

%Inizializzazione numero nodi Gauss-Hammer
nGH = methodInfo.numNodiExt;
nSR = methodInfo.numSubRegion;
nNS = methodInfo.numNodiSing;

%% CALCOLO INTEGRALI

%Calcolo indice temporale
istTemp = indTemp + [1, 0, -1];

%Ciclo sui tre istanti temporali
for var = 1 : 3
    %Controllo necessità di calcolo del sottonucleo
    if(istTemp(var) <= 0)
        continue
    end
    intgGHGHC = zeros(3, 3);

    %Calcolo parametro temporale del sottonucleo
    currT = istTemp(var) * deltaT;
    
    for indGH = 1 : nGH
        nodoExt = GHnodesS{indGH};
        intgGHC = zeros(3, 3);

        for indSR = 1 : nSR
            for indNS = 1 : nNS
                indNodo = (nNS * (indSR - 1)) + indNS;

                nodoInt = GHCnodesF{indNodo};

                vettX = nodoInt - nodoExt;
                lungX = norm(vettX);

                intgGHC = intgGHC + GHCweightsF{indNS} .* nu(vettX, lungX, currT);
            end
        end
        
        intgGHGHC = intgGHGHC + GHweightsS{indGH} .* intgGHC;
    end

    ris = ris + coef(var) .* intgGHGHC;
end

%Applicazione coefficiente moltiplicativo comune
ris = ris ./ (4*pi*pbParam.rho);

return